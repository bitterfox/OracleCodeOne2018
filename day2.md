
- AdoptOpenJDK
  - background
    - JDK: JRE + tools for developer
    - OracleJDK vs OpenJDK
    - OpenJDK vs IcedTea, Zulu, OpenJ9
    - Java Is Still Free
  - What is AdoptOpenJDK
    - build farm for OpenJDK
    - History
    - Betterrev
      - Difficult to contribute
      - Make it easier
      - ended in 2016
    - Build OpenJDK and deliver it
      - A lot of companies like IBM, Azul and a lot of communities like LJC contribute to the project
    - IBM is building and deliver OpenJ9 on AdoptOpenJDK
      - IBM donate testing infrastructure
  - Build farm
    - Build OpenJDK for different archtecture and with different JVM
    - Clone Mercurial repo to github -> jenkins -> build -> test -> ship
    - Demo
  - CI
    - Binary deploy mentioned above
    - Website deploy
  - Host prep
    - machines must have different arctecture and OS
    - Keep tools and dependencies consitent between machines
      - They use Ansible to do it
      - They like agentless and simple yaml syntax
  - Use Jenkins for CI
    - Pipeline
    - Dynamic host selection
    - Lessons
      - Source controlled build pipeline
      - Build failure tracking
  - Build scripts
    - Bash
    - Future
      - Produce installer
  - Archive
     - Use github releases
  - Testing
    - testkitgen
      - a lot of tests in addition to openjdk tests

- Flight recorder
  - record events time period
    - API to produce events
  - Events
    - JVM
      - GC
      - Runtime
      - Compiler
      - Configuration
    - Java application
      - Exceptions
      - Allocations, old objects...
    - OS
  - Usecase
    - Correctness
      - Ensure added new code doesn't make GC bad based on the metrics of flight recorder
    - Performance and scalability
    - Trouble shooting
  - After JDK11
    - it will be open sourced, free to use
    - as well as Mission control
  - Demo
    - -XX:StartFlightRecording:<bytes>
    - -XX:StartFlightRecording:filename=<name>
    - -XX:StartFlightRecording:settings=hoge.jfc
      - xml format
    - JFR.dump and etc is avaiable in jcm
      - jcmd <pid> JFR.dump
    - jfr command will be avaiable after jdk 12
      - jfr print
      	- --events
      - jfr summary
    - jdk.jfr.Event and Label for custom events
    - visualize by jmc
  - Own events
    - Name, Label, Description, etc
      - meta data is important
    - Content Type
      - Percentage, Frequency, Timespan, Timestamp, DataAmount
    - periodic event
    - ```
    event = new Event
    event.begin
    hoge
    event.end
    event.hoge = ""
    event.commit
    ```
    - Enable annotation
      - enable on test env, and disable production env
  - Read events
    - RecordingFile.readAllEvents
  - practical demo
  - overhead for disabled event
    - no overhead due to start, end and commit by Dead code elimination
    - no overhead for new Event by escape analysis and scalar replacement
    - field assignment also no overhead by dead code elimination
    - completaly no overhead for disabled event
  - Future work
    - Event streaming
      - currently need to start stop dump jfr

- Vector API
  - API  to use vectorlization of CPU
  - Motivation
    - Auto vectorlization is hard to do
    - express data vectorlized code
      - For Machine larning, etc
  - FloatVector length, add, mul, etc
  - Auto vectorlizer is on average better for simple case
  - Byte,Short,FloatVector extend Vector
    - Byte128Vector extends ByteVector
  - example
    - hash code
      - 3~8% faster with vector api
    - branch
      - a > 0 ? a : a + 1
      - Mask mask = av.greaterThan
      	- vblendvps
    - Sepia filter
    - dot product
      - over 5 time faster than scaler unrolled with vector rolled
    - mandelbro
      - 4~5 times faster than scaler
  - implementation
    - they want valut types to represent vector object effectively
    - intrinsics on hotspot
      - VectorIntrinsics
      - vectorlized machine code is generated based on the information
      - if vectorlization is not supported the default operation is used
      
- Lang and tools
  - Lang
    - LVTI
      - var
      - var for lambda parameter is introduced in JDK 11
      - style guideline
      	- choose a variable name that provide useful incofmation
	  - not only var context
	- use var when initializer part provide enough information for reader
	  - var reader = new BufferedReader
	- Don't worry too much about programming to the interface with local variable
	  - var list = new ArrayList<String>() where list is not List but ArrayList, but ok for local variable
	- take care using var for literal
	  - var bool = true; ok
	  - var byteVal = 1; instead of byte byteVal = 1; NG
	- take care when using with diamond or generic method
	  - var list = Collection.emptyList()
	- splitting complex streaming call chains
    - Preview Language and VM Features [JEP 12]
      - in JDK 11
      - javac --enable-preview --source X
      - java --enable-preview
    - Switch expr
      - preview in jdk 12
      - no fall-through
      - better slope strategy
      - switch expr is poly type
      - break with value
        - case HOGE -> {hoge; break value;}
      - need all case are covered
    - raw string
      - preview in jdk 12
      - no \n or \uXXX
      - one or more `
        - `Hello double backtick `` world`
        - `` Hello single ` ``
        - ```hoge ` hoge `` hoge```
        - no empty string by raw str(`` is error)
        - "\\d\\d" -> `\d\d`
        - "\"C:\\Program Files"->`"C:\Program Files`
        - align, indent, lines, isBlank is introduced for raw string literal
  - Tool
    - Launch Single-File Source-Code Programs
      - JDK 11
      - java HelloWorld.java
  - Javadoc
    - Javadoc.Next in jdk9
  - Deprecation
    - javah
      - removed in jdk10
    - Nashorn
    - Pack200
  - Projects
    - Amber
    - Panama
    - Valhalla

- Goldman sacks

- Keynote
  - Oracle cloud
  - OSS
  - cloud native, CNCF
  - Fn

